<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=1900">
    <title>o22-5</title>
    <style>
        html,
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
    <link rel="stylesheet" href="vendor/reveal/reset.css">
    <link rel="stylesheet" href="vendor/reveal/reveal.css">
    <link rel="stylesheet" href="vendor/reveal/theme/sky.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="vendor/reveal/plugin/highlight/zenburn.css">
    <!--edit-->
    <!-- Pollyfill script -->
    <script src="https://unpkg.com/core-js-bundle@3.6.1/minified.js"></script>
    <!-- Live2DCubismCore script -->
    <script src="./dist/live2dcubismcore.js"></script>
    <!-- Build script -->
    <script src="./dist/bundle.js"></script>
    <style>
        ul,
        ol {
            list-style: none;
            margin-left: 0;
        }

        .reveal {
            position: absolute;
            left: 0;
            top: 0;
            font-size: 26px;
        }

        #pageIndex {
            position: absolute;
            right: 24px;
            bottom: 24px;
            background: #000;
            color: #fff;
            font-size: 20px;
        }

        .controls {
            bottom: 24px !important;
        }
    </style>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <!--
            data-no: 老師網頁的cubism人物編號(從0開始，網頁上的編號-1)
            data-positionx: cubism人物水平位移範圍(建議-1 ~ 0.9)
            data-positiony: cubism人物垂直位移範圍(建議-0.9~0.4)
            data-scale: cubism人物縮放(建議1~2之間的小數值，最大極限是3)
            data-motionno: cubism人物指定動作編號(從0開始，請參閱model3.json檔案的ALL MOTION GROUP)
            -->

            <section>
                <h3>多項式相加、相減、相乘(進階題2)</h3>
                <section data-no="6" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <span style="color:red;">(使用以下 struct 與 Linked List 實作才計分)</span><br>
                    (1) void add(pol_t* X, pol_t* Y, pol_t* Z); //兩個多項式 X, Y 相加,Z 是結果<br><br>
                    (2) void sub(pol_t* X, pol_t* Y, pol_t* Z); //兩個多項式 X, Y 相減,Z 是結果<br><br>
                    (3) void mul(pol_t* X, pol_t* Y, pol_t* Z); //兩個多項式 X, Y 相乘,Z 是結果<br><br>
                    <span style="color:red;">
                    typedef struct node_s {<br>
                        &emsp;&emsp;int coef;<br>
                        &emsp;&emsp;int exp;<br>
                        &emsp;&emsp;struct node_s * next;<br>
                    } node_t;<br><br>

                    typedef node_t * nodep_t; //此行重新命名node_t*，之後nodep_t 都代表node_t*<br><br> 

                    typedef struct pol_s {<br>
                        &emsp;&emsp;nodep_t root;<br>
                    } pol_t;
                    </span>
                </section>
            </section>

            <section>
                <h3>多項式相加、相減、相乘(進階題2)</h3>
                <section data-no="6" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <img src="img/ch17-2/06_i.png" style="display:block; margin:auto;">
                </section>
            </section>

            <section>
                <h3>多項式相加、相減、相乘(進階題2)</h3>
                <section data-no="6" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <img src="img/ch17-2/06_in_out1.png" style="display:block; margin:auto;">
                </section>
            </section>

            <section>
                <h3>多項式相加、相減、相乘(進階題2)</h3>
                <section  data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <img src="img/ch17-2/06_in_out2.png" style="display:block; margin:auto;">
                </section>
            </section>

            <section>
                <h3>多項式相加、相減、相乘(進階題2)</h3>
                <section data-no="6" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <img src="img/ch17-2/06_in_out3.png" style="display:block; margin:auto;">
                </section>
            </section>

            
            <section>
                <h3>多項式相加、相減、相乘(進階題2)</h3>
                <section
                data-no="6"
                 data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    5<br>
                    2 3 0 1 -1<br>
                    6<br>
                    1 0 -1 4 -3 2<br><br>
                    1 5 2 4 2 3 4 2 -2 1 1 0<br> 
                    -1 5 2 4 4 3 -4 2 4 1 -3 0 <br>
                    2 9 3 8 -2 7 6 6 5 5 -6 4 11 3 -7 2 5 1 -2 0 
                </section>
                <section
                data-no="6"
                 data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    6<br>
                    1 0 -1 4 -3 2<br>
                    2<br>
                    1 1<br><br>
                    1 5 0 4 -1 3 4 2 -2 1 3 0<br> 
                    1 5 0 4 -1 3 4 2 -4 1 1 0<br>
                    1 6 1 5 -1 4 3 3 1 2 -1 1 2 0 
                </section>
                <section
                data-no="6"
                 data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    4<br>
                    9 -8 3 -2<br>
                    4<br>
                    11 3 -4 2<br><br>
                    20 3 -5 2 -1 1 0 0<br> 
                    -2 3 -11 2 7 1 -4 0 <br>
                    99 6 -61 5 -27 4 37 3 -34 2 14 1 -4 0 
                </section>
                <section
                data-no="6"
                 data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    5<br>
                    1 2 3 4 5<br>
                    5<br>
                    -1 -2 -3 -4 -5<br><br>
                    0 4 0 3 0 2 0 1 0 0 <br>
                    2 4 4 3 6 2 8 1 10 0 <br>
                    -1 8 -4 7 -10 6 -20 5 -35 4 -44 3 -46 2 -40 1 -25 0 
                </section>
                <section
                data-no="6"
                 data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    5<br>
                    5 4 3 2 1<br>
                    5<br>
                    5 4 3 2 1<br>
                    10 4 8 3 6 2 4 1 2 0<br> 
                    0 4 0 3 0 2 0 1 0 0 <br>
                    25 8 40 7 46 6 44 5 35 4 20 3 10 2 4 1 1 0 
                </section>
            </section>

            <section>
                <h3>Tips</h3>
                <section data-no="17" data-positionx="0.75" data-positiony="0.05" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers="|1-15|17-33|"><script type="text/template">
                        #include <stdio.h>
                        #include <stdlib.h>
                        #include <stdbool.h>

                        typedef struct node_s {
                            int coef;
                            int exp;
                            struct node_s * next;
                        } node_t; 
                        
                        typedef node_t * nodep_t; // 此行重新命名node_t*，之後nodep_t 都代表node_t*
                        
                        typedef struct pol_s {
                            nodep_t root;
                        } pol_t; // pol_t是指Linked list的第一個node。
                        
                        void add(pol_t* X, pol_t* Y, pol_t* Z); //兩個多項式 X, Y 相加,Z 是結果
                        void sub(pol_t* X, pol_t* Y, pol_t* Z); //兩個多項式 X, Y 相減,Z 是結果
                        void mul(pol_t* X, pol_t* Y, pol_t* Z); //兩個多項式 X, Y 相乘,Z 是結果
                        
                        nodep_t createList(int); // 串列建立函數
                        void printList(nodep_t);  // 串列列印函數 
                        
                        int main()
                        {
                            nodep_t x_first;

                            pol_t *x;

                            x = (pol_t *) malloc(sizeof(pol_t));
                            
                            x->root = x_first;
                        }
                    </script></code></pre>
                </section>
            </section>

            <section>
                <h3>解答P1</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    &emsp;&emsp;首先引用函式庫並依照題目使用 struct 定義節點結構<br>
                    &emsp;&emsp;重新命名node_t*，令之後nodep_t 都代表node_t*<br>
                    &emsp;&emsp;使用 struct 定義存放根結點的結構<br>
                    <section data-auto-animate>
                    <pre><code data-trim data-noescape>
                    #include &lt;stdio.h&gt;
                    #include &lt;stdlib.h&gt;
                    #include &lt;stdbool.h&gt;
                    
                    typedef struct node_s {
                        int coef;
                        int exp;
                        struct node_s * next;
                    } node_t; 
                    
                    typedef node_t * nodep_t; // 此行重新命名node_t*，之後nodep_t 都代表node_t*
                    
                    typedef struct pol_s {
                        nodep_t root;
                    } pol_t; // pol_t 是指Linked list的第一個node。
                    </code></pre>
                    </section>
                </section>
            </section>

            <section>
                <h3>解答P2</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    &emsp;&emsp;宣告函式 add 用來進行多項式相加<br>
                    &emsp;&emsp;宣告函式 sub 用來進行多項式相減<br>
                    &emsp;&emsp;宣告函式 mul 用來進行多項式相減<br>
                    &emsp;&emsp;宣告函式 createList 用來建立串列<br>
                    &emsp;&emsp;宣告函式 printList 用來列印串列<br>
                    <section data-auto-animate>
                    <pre><code data-trim data-noescape>
                    void add(pol_t* X, pol_t* Y, pol_t* Z); //兩個多項式 X, Y 相加,Z 是結果
                    void sub(pol_t* X, pol_t* Y, pol_t* Z); //兩個多項式 X, Y 相減,Z 是結果
                    void mul(pol_t* X, pol_t* Y, pol_t* Z); //兩個多項式 X, Y 相減,Z 是結果
                    
                    nodep_t createList(int); // 串列建立函數
                    void printList(nodep_t);  // 串列列印函數
                    </code></pre></section></section>
            </section>

            <section>
                <h3>解答P3</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    &emsp;&emsp;開始寫主函式<br>
                    &emsp;&emsp;宣告整數 x_node_num, y_node_num 用來存放使用者輸入的節點數目<br>
                    &emsp;&emsp;宣告指標 x_first, y_first, z_first, new_node，<br>
                    &emsp;&emsp;分別指向第一、第二個多項式，結果多項式，以及新的節點<br>
                    &emsp;&emsp;宣告指標 x, y, z 分別指向多項式 x, 多項式 y, 多項式 z 的根節點
                    <section data-auto-animate>
                    <pre><code data-trim data-noescape>
                      int main()
                      {
                          int x_node_num, y_node_num;
                          nodep_t x_first, y_first, z_first, new_node; // 4個指標，分別指向第一、第二個多項式，結果多項式，以及新的節點
                          pol_t *x, *y ,*z;
                          x = (pol_t *) malloc(sizeof(pol_t));
                          y = (pol_t *) malloc(sizeof(pol_t));
                          z = (pol_t *) malloc(sizeof(pol_t));
                    </code></pre></section></section>
            </section>

            <section>
                <h3>解答P4</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    &emsp;&emsp;讓使用者輸入多項式 x 的節點數目<br>
                    &emsp;&emsp;創建多項式 x 的串列，並將 x->root 指向第一個節點<br>
                    &emsp;&emsp;讓使用者輸入多項式 y 的節點數目<br>
                    &emsp;&emsp;創建多項式 y 的串列，並將 y->root 指向第一個節點<br>
                    &emsp;&emsp;創建一個節點，並將 z_first, z->root 指向這個節點<br>
                    &emsp;&emsp;使用函式 add, sub, mul 進行多項式相加、相減、相乘<br>
                    &emsp;&emsp;主函式結束
                    <section data-auto-animate>
                    <pre><code data-trim data-noescape>
                          scanf("%d",&x_node_num);
                          x_first = createList(x_node_num);
                          x->root = x_first;
                      
                          scanf("%d",&y_node_num);
                          y_first = createList(y_node_num);
                          y->root = y_first;
                      
                          new_node=(nodep_t) malloc(sizeof(node_t));
                          new_node->exp = 100;
                          z_first = new_node;
                          z->root = z_first;
                      
                          add(x, y, z);
                          z_first->next = NULL;
                          sub(x, y, z);
                          z_first->next = NULL;
                          mul(x, y, z);
                          return 0;
                      }
                    </code></pre></section></section>
            </section>

            <section>
                <h3>解答P5</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    定義串列建立函數
                    <pre><code data-trim data-noescape>
                    // 串列建立函數
                    nodep_t createList(int len){
                        nodep_t first, current, previous; // 3個指標，分別指向第一個節點、當前節點、前一個節點
                        for(int i=0;i < len;i++){
                            current=(nodep_t) malloc(sizeof(node_t)); // 建立新節點並令 current 指向新節點
                            scanf("%d",&(current->coef));  // 設定節點的資料成員(係數)
                            current->exp = len - 1 - i; // 設定節點的資料成員(次方)，次方 = 項數個數 - 1 - 已跑迴圈數
                            if(i==0){
                                first=current;  // 如果是第一個成員令指標 frist 指向目前的節點 
                            }
                            else{
                                previous->next=current; // 令前一個節點的 next 指向目前的節點 
                            }
                            current->next=NULL; // 令目前節點的 next 設為 NULL
                            previous=current; // 令指向前一個節點的指標指向目前節點 
                        }
                        return first;
                    }
                    </code></pre></section>
            </section>

            <section>
                <h3>解答P6</h3>
                <section data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>  
                    定義串列列印函數
                    <pre><code data-trim data-noescape>                
                    //串列列印函數
                    void printList(nodep_t first){
                    	nodep_t node = first -> next, p = NULL; // 將node指向第一個節點(跳過z最前面的節點)，p 指向將釋放的節點
                    	if(node == NULL){
                    		printf("None\n");
                    	}
                        else{
                    		while(node != NULL){
                    			printf("%d %d ", node->coef, node->exp); // 輸出係數和次方
                    			node = node->next;
                    		}
                    		printf("\n");
                    	}
                        
                        if(first -> next != NULL){
                            node = first -> next;
                            while(node != NULL){ // 釋放動態記憶體空間
                                p = node;
                                node = node->next;
                                free(p);
                            }
                        }
                    } 
                    </code></pre></section>
            </section>

            <section>
                <h3>解答P7</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>  
                    定義減法函式
                    <pre><code data-trim data-noescape>                    
                      void sub(pol_t* X, pol_t* Y, pol_t* Z)
                      {
                          nodep_t x_current, y_current, z_current, z_root, new_node;
                          // 5個指標，分別指向 x, y, z 的當前節點， z 的第一個節點，以及新的節點
                      
                          x_current = X->root;
                          y_current = Y->root;
                          z_current = Z->root;
                          z_root = Z->root;
                    </code></pre></section>
            </section>

            <section>
                <h3>解答P8</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left">
                    定義減法函式
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers="|1-18|19-32|"><script type="text/template">
                      while (1)
                      {
                          if(x_current == NULL || y_current == NULL)
                              break;
                          if( x_current->exp > y_current->exp ) // 若當前多項式 x 的項次方大於多項式 y 的項次方
                          {
                              new_node=(nodep_t) malloc(sizeof(node_t)); // 建立新節點，存進當前多項式 x 的項
                              new_node->coef = x_current->coef;
                              new_node->exp = x_current->exp;
                              x_current = x_current->next;
                          }
                          else if( x_current->exp < y_current->exp ) // 若當前多項式 x 的項次方小於多項式 y 的項次方
                          {
                              new_node=(nodep_t) malloc(sizeof(node_t)); // 建立新節點，存進加上負號的當前多項式 y 的項
                              new_node->coef = -y_current->coef;
                              new_node->exp = y_current->exp;
                              y_current = y_current->next;
                          }
                          else // 若兩者的項次方相等
                          {
                              new_node=(nodep_t) malloc(sizeof(node_t)); // 建立新節點
                              new_node->coef = x_current->coef - y_current->coef; // 存進當前多項式 x 的項係數減當前多項式 y 的項係數
                              new_node->exp = x_current->exp; // 存進當前多項式 x 的項次方
                              x_current = x_current->next;
                              y_current = y_current->next;
                          }
                              z_current->next = new_node; // 將當前 z 的指標 next 指向新的節點
                              z_current = z_current->next; // 把後一個節點設成當前節點 
                              z_current->next = NULL; // 把當前節點(本輪的新節點)的指標 next 設為 NULL
                      }
                      printList(z_root); // 做完減法即列印多項式 z
                  }
                    </script></code></pre></section>
            </section>

            <section>
                <h3>解答P9</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>      
                    定義加法函式            
                    <pre><code data-trim data-noescape>
                      void add(pol_t* X, pol_t* Y, pol_t* Z)
                      {
                          nodep_t x_current, y_current, z_current, z_root, new_node;
                          // 5個指標，分別指向 x, y, z 的當前節點， z 的第一個節點， 以及新的節點
                      
                          x_current = X->root;
                          y_current = Y->root;
                          z_current = Z->root;
                          z_root = Z->root;
                    </code></pre></section>
            </section>

            <section>
                <h3>解答P10</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left">    
                    定義加法函式            
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers="|1-18|19-32|"><script type="text/template">     
                      while (1)
                      {
                          if(x_current == NULL || y_current == NULL)
                              break;
                          if( x_current->exp > y_current->exp ) // 若當前多項式 x 的項次方大於多項式 y 的項次方
                          {
                              new_node=(nodep_t) malloc(sizeof(node_t)); // 建立新節點，存進當前多項式 x 的項
                              new_node->coef = x_current->coef;
                              new_node->exp = x_current->exp;
                              x_current = x_current->next;
                          }
                          else if( x_current->exp < y_current->exp ) // 若當前多項式 x 的項次方小於多項式 y 的項次方
                          {
                              new_node=(nodep_t) malloc(sizeof(node_t)); // 建立新節點，存進當前多項式 y 的項
                              new_node->coef = y_current->coef;
                              new_node->exp = y_current->exp;
                              y_current = y_current->next;
                          }
                          else // 若兩者的項次方相等
                          {
                              new_node=(nodep_t) malloc(sizeof(node_t));
                              new_node->coef = x_current->coef + y_current->coef; // 存進當前多項式 x 的項係數加當前多項式 y 的項係數
                              new_node->exp = x_current->exp; // 存進當前多項式 x 的項次方
                              new_node->exp = x_current->exp;
                              x_current = x_current->next;
                              y_current = y_current->next;
                          }
                          z_current->next = new_node;
                          z_current = z_current->next;
                          z_current->next = NULL;
                      }
                      printList(z_root); // 做完加法即列印多項式 z
                  }
                    </script></code></pre></section>
            </section>

            <section>
                <h3>解答P11</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>        
                    定義乘法函式                 
                    <pre><code data-trim data-noescape>              
                      void mul(pol_t* X, pol_t* Y, pol_t* Z)
                      {
                          int product_exp; // x * y的次方項
                          bool exp_exist = false; // 看 z 的 Linked list 中是否已經出現過 x * y 的次方 , false 表示未出現
                          nodep_t x_current, y_current, z_current, z_root, new_node;
                      
                          x_current = X->root;
                          y_current = Y->root;
                          z_current = Z->root;
                          z_root = Z->root;
                    </code></pre></section>
            </section>

            <section>
                <h3>解答P12</h3>
                <section data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>        
                    定義乘法函式                      
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers="|1-14|16-27|29-45|"><script type="text/template">              
                      while (1)   // 讓 y 的每一項去 * x 每一項
                      {
                          exp_exist = false;
                          z_current = Z->root;
                  
                          if(x_current == NULL) // y 的當前項已經乘上 x 的每一項
                          {
                              y_current = y_current->next; // 到 y 的下一項
                              x_current = X->root; // 從頭開始乘上 x 的每一項
                          }
                          if(y_current == NULL) // y 的每個項已經乘上 x 的每一項
                              break;
                          
                          product_exp = x_current->exp + y_current->exp; // 次方項相乘結果為相加

                          while (z_current != NULL) // 判斷 z 是否為空串列
                          {
                              if(z_current->exp == product_exp) // 看 z 的 Linked list 中是否已經出現過 x * y 的次方
                              {
                                  exp_exist = true;
                                  break;
                              }
                              if(z_current->next != NULL)
                                  z_current = z_current->next; // 檢查 z 的下一項
                              else
                                  break;
                          }
                          
                          if(exp_exist == false) // x * y 的次方項不在 z 中，則建立新節點
                          {
                              new_node=(nodep_t) malloc(sizeof(node_t)); // 建立新節點
                              new_node->coef = x_current->coef * y_current->coef; // 存進係數相乘結果
                              new_node->exp = product_exp; // 存進次方項相乘結果
                              z_current->next = new_node;
                              z_current = z_current->next;
                              z_current->next = NULL;
                          }
                          else // x * y 的次方項在 z 中，則直接更新該系數
                          {
                              z_current->coef += x_current->coef * y_current->coef; // 加進係數相乘結果
                          }
                          x_current = x_current->next;
                      }
                      printList(z_root); // 做完乘法即列印多項式 z
                  }
                    </script></code></pre></section>
            </section>
          
        </div>
    </div>
    <div id="pageIndex"></div>
    <!-- reveal.js-->
    <script src="vendor/reveal/reveal.js"></script>
    <!--plugin-->
    <script src="vendor/reveal/plugin/math/math.js"></script>
    <script src="vendor/reveal/plugin/search/search.js"></script>
    <script src="vendor/reveal/plugin/zoom/zoom.js"></script>

    <script src="vendor/reveal/plugin/notes/notes.js"></script>
    <script src="vendor/reveal/plugin/markdown/markdown.js"></script>
    <script src="vendor/reveal/plugin/highlight/highlight.js"></script>
    <script src="main-ppt.js"></script>
</body>

</html>
