<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=1900">
    <title>o22-3</title>
    <style>
        html,
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
    <link rel="stylesheet" href="vendor/reveal/reset.css">
    <link rel="stylesheet" href="vendor/reveal/reveal.css">
    <link rel="stylesheet" href="vendor/reveal/theme/sky.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="vendor/reveal/plugin/highlight/zenburn.css">
    <!--edit-->
    <!-- Pollyfill script -->
    <script src="https://unpkg.com/core-js-bundle@3.6.1/minified.js"></script>
    <!-- Live2DCubismCore script -->
    <script src="./dist/live2dcubismcore.js"></script>
    <!-- Build script -->
    <script src="./dist/bundle.js"></script>
    <style>
        ul,
        ol {
            list-style: none;
            margin-left: 0;
        }

        .reveal {
            position: absolute;
            left: 0;
            top: 0;
            font-size: 26px;
        }

        #pageIndex {
            position: absolute;
            right: 24px;
            bottom: 24px;
            background: #000;
            color: #fff;
            font-size: 20px;
        }

        .controls {
            bottom: 24px !important;
        }
    </style>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <!--
            data-no: 老師網頁的cubism人物編號(從0開始，網頁上的編號-1)
            data-positionx: cubism人物水平位移範圍(建議-1 ~ 0.9)
            data-positiony: cubism人物垂直位移範圍(建議-0.9~0.4)
            data-scale: cubism人物縮放(建議1~2之間的小數值，最大極限是3)
            data-motionno: cubism人物指定動作編號(從0開始，請參閱model3.json檔案的ALL MOTION GROUP)
            -->

            <section>
                <h3>Linked List 操作(進階題1)</h3>
                <section data-no="6" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <span style="color:red;">
                    本題須使用以下 Link List struct 實作才予計分。<br><br>
                    typedef struct node_s{<br>
                        &emsp;&emsp;int data;<br>
                        &emsp;&emsp;struct node_s *next;<br>
                    } node_t;</span><br><br>

                    針對空的 List,先進行 N 個資料節點加入,再進行加入、刪除、交換、反轉等操作。
                    輸出操作後 Linked List 資料。測試資料不會出現相同整數資料。
                </section>
            </section>

            <section>
                <h3>Linked List 操作(進階題1)</h3>
                <section data-no="6" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <img src="img/ch17-2/05_i.png" style="display:block; margin:auto;"><br>
                    <img src="img/ch17-2/05_in_out1.png" style="display:block; margin:auto;">
                </section>
            </section>

            <section>
                <h3>Linked List 操作(進階題1)</h3>
                <section data-no="6" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <img src="img/ch17-2/05_in_out1.png" style="display:block; margin:auto;"><br>
                    <img src="img/ch17-2/05_in_out11.png" style="display:block; margin:auto;">
                </section>
            </section>

            <section>
                <h3>Linked List 操作(進階題1)</h3>
                <section data-no="6" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <img src="img/ch17-2/05_in_out2.png" style="display:block; margin:auto;"><br>
                </section>
            </section>

            <section>
                <h3>Linked List 操作(進階題1)</h3>
                <section data-no="6" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <img src="img/ch17-2/05_in_out3.png" style="display:block; margin:auto;"><br>
                    <img src="img/ch17-2/05_in_out33.png" style="display:block; margin:auto;">
                </section>
            </section>
            
            <section>
                <h3>Linked List 操作(進階題1)</h3>
                <section data-no="6" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <img src="img/ch17-2/05_in_out4.png" style="display:block; margin:auto;"><br>
                    <img src="img/ch17-2/05_in_out44.png" style="display:block; margin:auto;">
                </section>
            </section>

            <section>
                <h3>Linked List 操作(進階題1)</h3>
                <section data-no="6" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <img src="img/ch17-2/05_in_out5.png" style="display:block; margin:auto;"><br>
                    <img src="img/ch17-2/05_in_out55.png" style="display:block; margin:auto;">
                </section>
            </section>

            <section>
                <h3>Linked List 操作(進階題1)</h3>
                <section data-no="6" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <img src="img/ch17-2/05_in_out6.png" style="display:block; margin:auto;"><br>
                    <img src="img/ch17-2/05_in_out66.png" style="display:block; margin:auto;">
                </section>
            </section>

            <section>
                <h3>Linked List 操作(進階題1)</h3>
                <section data-no="6" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <img src="img/ch17-2/05_in_out7.png" style="display:block; margin:auto;"><br>
                    <img src="img/ch17-2/05_in_out77.png" style="display:block; margin:auto;">
                </section>
            </section>

            <section>
                <h3>Linked List 操作(進階題1)</h3>
                <section
                data-no="6"
                 data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <table>
                      <tr>
                        <td>input</td>
                        <td>output</td></td>
                      </tr>
                      <tr>
                        <td>
                            1<br>
                            1<br>
                            3<br>
                            2<br>
                            1 2<br>
                            1 3 
                        </td>
                        <td>
                            2 3
                        </td>
                      </tr>
                      <tr>
                        <td>
                            1<br>
                            3<br>
                            2<br>
                            2<br>
                            2
                        </td>
                        <td>
                            None
                        </td>
                      </tr>
                    </table>
                </section>
                <section
                data-no="6"
                 data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <table>
                      <tr>
                        <td>input</td>
                        <td>output</td></td>
                      </tr>
                      <tr>
                        <td>
                            3<br>
                            1 2 3<br>
                            4<br>
                            3<br>
                            3<br>
                            3<br>
                            3
                        </td>
                        <td>
                            None
                        </td>
                      </tr>
                      <tr>
                        <td>
                            5<br>
                            1 2 3 4 5<br>
                            4<br>
                            4 1<br>
                            4 5<br>
                            4 3<br>
                            4 6
                        </td>
                        <td>
                            2 4
                        </td>
                      </tr>
                    </table>
                </section>
                <section
                data-no="6"
                 data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <table>
                      <tr>
                        <td>input</td>
                        <td>output</td></td>
                      </tr>
                      <tr>
                        <td>
                            5<br>
                            1 2 3 4 5<br>
                            4<br>
                            5 1 7<br>
                            5 5 8<br>
                            5 3 9<br>
                            5 6 10
                        </td>
                        <td>
                            1 7 2 3 9 4 5 8 
                        </td>
                      </tr>
                      <tr>
                        <td>
                            5<br>
                            1 2 3 4 5<br>
                            3<br>
                            6<br>
                            6<br>
                            6
                        </td>
                        <td>
                            5 4 3 2 1 
                        </td>
                      </tr>
                    </table>
                </section>
                <section
                data-no="6"
                 data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <table>
                      <tr>
                        <td>input</td>
                        <td>output</td></td>
                      </tr>
                      <tr>
                        <td>
                            8<br>
                            1 2 3 4 5 6 7 8<br>
                            4<br>
                            7 1 2<br>
                            7 7 8<br>
                            7 1 8<br>
                            7 2 7
                        </td>
                        <td>
                            7 8 3 4 5 6 1 2 
                        </td>
                      </tr>
                    </table>
                </section>
            </section>
            
            <section>
                <h3>Tips</h3>
                <section data-auto-animate data-no="17" data-positionx="0.75" data-positiony="0.05" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers="|1-18|20-40|"><script type="text/template">        
                        #include <stdio.h>
                        #include <stdlib.h>
                        #include <stdbool.h>
                            
                        typedef struct node_s{
                            int data;
                            struct node_s *next;
                        }node_t;
                            
                        node_t *createList(int); // 串列建立函數
                        node_t *add_Node(node_t *,int); // 1.從最後面加入資料 x 
                        node_t *delete_the_front(node_t *); // 2.刪除最前面節點，若 List 無節點，則不必刪除。
                        node_t *delete_the_back(node_t *); // 3.刪除最後面節點，若 List 已無節點，則不必刪除。
                        node_t *delete_x_node(node_t *, int); // 4.刪除 List 內資料為 x 的節點；若 x 不存在則不刪除任何節點。
                        node_t *add_y_node(node_t *, int, int); // 5.搜尋 List 內資料為 x 的節點，並在其後加入數值 y 的新節點。若 x 不在 List 中，則不必加入 y 。
                        node_t *Reverse(node_t *);// 6. 反轉 Link List。
                        node_t *Change_position(node_t *, int, int);// 7. 交換數值為 x 和 y 節點的位置，若 x 或 y 不在 List中，則不必交換。
                        void printList(node_t *);  // 串列列印函數

                        int main()
                        {
                            node_t *first;
                            first = createList(node_num);

                            printList(first);
                        }

                        //串列列印函數
                        void printList(node_t *first){
                            node_t *node = first; //將node指向第一個節點
                            if(first == NULL){
                                printf("None\n");
                            }else{
                                while(node != NULL){
                                    printf("%d ",node->data);
                                    node = node->next;
                                }
                                printf("\n");
                            }
                        } 
                    </script></code></pre>
                </section>
            </section>

            <section>
                <h3>解答P1</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    &emsp;&emsp;首先引用函式庫並使用 struct 定義節點結構<br>
                    &emsp;&emsp;節點結構由一整數空間與一存放節點型態指標的空間組成<br>
                    &emsp;&emsp;宣告整數變數 data 用於存放節點資料<br>
                    &emsp;&emsp;宣告型態為 struct node_s 的指標 next 用於指向下一個節點<br>
                    &emsp;&emsp;使用 typedef 定義結構 struct node_s 的別名為 node_t，方便撰寫程式
                    <section data-auto-animate>
                      <pre><code data-trim data-noescape>        
                        #include &lt;stdio.h&gt;
                        #include &lt;stdlib.h&gt;
                        #include &lt;stdbool.h&gt;

                        typedef struct node_s{
                            int data;
                            struct node_s *next; // 指向下一個節點
                        }node_t;
                      </code></pre> 
                    </section>
                </section>
            </section>

            <section>
                <h3>解答P2</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    &emsp;&emsp;宣告函式 createList 用來建立串列<br>
                    &emsp;&emsp;宣告函式 add_Node 用來完成指令1<br>
                    &emsp;&emsp;宣告函式 delete_the_front, delete_the_back, delete_x_node，<br>
                    &emsp;&emsp;分別用來完成指令2, 3, 4<br>
                    &emsp;&emsp;宣告函式 add_y_node 用來完成指令5<br>
                    &emsp;&emsp;宣告函式 Reverse 用來完成指令6<br>
                    &emsp;&emsp;宣告函式 Change_position 用來完成指令7
                    <section data-auto-animate>
                      <pre><code data-trim data-noescape>        
                        node_t *createList(int); // 串列建立函數

                        node_t *add_Node(node_t *,int); // 1.從最後面加入資料 x 

                        node_t *delete_the_front(node_t *); // 2.刪除最前面節點，若 List 無節點，則不必刪除。
                        node_t *delete_the_back(node_t *); // 3.刪除最後面節點，若 List 已無節點，則不必刪除。
                        node_t *delete_x_node(node_t *, int); // 4.刪除 List 內資料為 x 的節點；若 x 不存在則不刪除任何節點。

                        node_t *add_y_node(node_t *, int, int); // 5.搜尋 List 內資料為 x 的節點，並在其後加入數值 y 的新節點。若 x 不在 List 中，則不必加入 y 。

                        node_t *Reverse(node_t *); // 6. 反轉 Link List。
                        node_t *Change_position(node_t *, int, int); // 7. 交換數值為 x 和 y 節點的位置，若 x 或 y 不在 List中，則不必交換。

                        void printList(node_t *);  // 串列列印函數 
                      </code></pre> 
                    </section>
                </section>
            </section>

            <section>
                <h3>解答P3</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    &emsp;&emsp;開始寫主函式<br>
                    &emsp;&emsp;宣告整數 node_num, op_num 分別存放節點數量和操作指令數量<br>
                    &emsp;&emsp;宣告整數 x, y 存放整數資料 x, y<br>
                    &emsp;&emsp;讓使用者輸入節點數並使用函式 createList 創建節點<br>
                    &emsp;&emsp;讓使用者輸入操作指令的數量 
                    <section data-auto-animate>
                      <pre><code data-trim data-noescape>        
                        int main()
                        {
                            int node_num, op_num, x, y;
                            node_t *first;
                            scanf("%d",&node_num); // 讓使用者輸入節點數
                            first = createList(node_num); // 使用函式 createList 創建節點
                            scanf("%d",&op_num); // 讓使用者輸入操作指令的數量               
                      </code></pre> 
                    </section>
                </section>
            </section>

            <section>
                <h3>解答P4</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    &emsp;&emsp;在執行完全部的操作指令前持續執行迴圈<br>
                    &emsp;&emsp;讓使用者輸入操作指令，並使用 switch 選擇對應的使用函式<br>
                    &emsp;&emsp;case 1~4 使用各自的函式對串列進行加入和刪除的操作<br>
                    &emsp;&emsp;case 5~7 使用各自的函式對串列執行搜尋後加入節點、反轉和交換節點的操作<br>
                    &emsp;&emsp;每執行完一個指令令操作指令的數量減一，執行完全部指令時印出函式<br>
                    &emsp;&emsp;主函式結束
                    <section data-auto-animate>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers="|1-5|6-24|26-47|"><script type="text/template"> 
                            while (op_num > 0)
                            {
                                int op;
                                scanf("%d",&op); // 讓使用者輸入操作指令
                                switch (op)
                                {
                                case 1: // 1.從最後面加入資料 x 
                                    scanf("%d",&x);
                                    first = add_Node(first,x);
                                    break;

                                case 2: // 2.刪除最前面節點，若 List 無節點，則不必刪除。
                                    if(first != NULL)
                                        first = delete_the_front(first);
                                    break;

                                case 3: // 3.刪除最後面節點，若 List 已無節點，則不必刪除。
                                    if(first != NULL)
                                        first = delete_the_back(first);
                                    break;
                                case 4: // 4.刪除 List 內資料為 x 的節點；若 x 不存在則不刪除任何節點。
                                    scanf("%d",&x);
                                    first = delete_x_node(first, x);
                                    break;

                                case 5: // 5.搜尋 List 內資料為 x 的節點，並在其後加入數值 y 的新節點。若 x 不在 List 中，則不必加入 y 。
                                    scanf("%d %d",&x,&y);
                                    first = add_y_node(first, x, y);
                                    break;

                                case 6: // 6. 反轉 Link List。
                                    first = Reverse(first);
                                    break;

                                case 7: // 7. 交換數值為 x 和 y 節點的位置，若 x 或 y 不在 List中，則不必交換
                                    scanf("%d %d",&x,&y);
                                    first = Change_position(first, x, y);//
                                    break;

                                default:
                                    break;
                                }
                                op_num--;
                            }
                            printList(first);
                            return 0;
                        }
                      </script></code></pre> 
                    </section>
                </section>
            </section>

            <section>
                <h3>解答P5</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    &emsp;&emsp;定義函式 createList 建立函數，函式 createList 回傳一節點型態的指標<br>
                    &emsp;&emsp;宣告指標 first, current, previous 分別指向第一個節點、當前節點、先前節點<br>
                    &emsp;&emsp;使用函式 malloc 動態配置空間給新節點，並令 current 指向新節點<br>
                    &emsp;&emsp;令使用者輸入當前節點要存放的資料<br>
                    &emsp;&emsp;當當前節點為第一個成員，令 frist 指向目前的節點<br>
                    &emsp;&emsp;否則令前一個節點的指標 next 指向目前的節點<br>
                    &emsp;&emsp;令 previous 指向目前的節點，一開始 previous 會是 first<br>
                    &emsp;&emsp;串列建立完畢，回傳 first
                    <section data-auto-animate>
                      <pre><code data-trim data-noescape>        
                        //串列建立函數 
                        node_t *createList(int len){
                            node_t *first, *current, *previous; // 指向第一個節點、當前節點、先前節點的三個指標
                            for(int i = 0; i < len; i++){
                                current = (node_t *) malloc(sizeof(node_t)); // 建立新節點
                                scanf("%d",&(current->data));  // 設定節點的資料成員
                                if(i == 0){
                                first = current;  // 如果是第一個成員把指標frist指向目前的節點 
                                }
                                else{
                                    previous->next = current; // 把前一個的next指向目前的節點 
                                }
                                current->next = NULL; // 把目前的節點的next指向NULL
                                previous = current; // 把前一個節點設成目前的節點，最初 previous 會是 first
                            }
                            return first;
                        }
                      </code></pre> 
                    </section>
                </section>
            </section>

            <section>
                <h3>解答P6</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    &emsp;&emsp;定義函式 add_Node 在串列結尾新增節點<br>
                    &emsp;&emsp;宣告指標 new_node, current 分別指向新節點和當前節點<br>
                    &emsp;&emsp;使用函式 malloc 動態配置空間給新節點，並令 new_node 指向新節點<br>
                    &emsp;&emsp;判斷目前是否為最後一個節點，若是最後一個節點則令節點的 next 指向新節點<br>
                    &emsp;&emsp;若串列不存在，令 first 指向新節點<br>
                    &emsp;&emsp;設定新節點的 data 和 next，回傳 first
                    <section data-auto-animate>
                      <pre><code data-trim data-noescape>        
                        //從最後面加入資料 x 
                        node_t *add_Node(node_t *first,int data){
                            node_t *new_node,*current;
                            current = first;
                            new_node = malloc(sizeof(struct node_s)); // 建立新節點

                            if(first!=NULL){ // 判斷串列是否存在
                                while (current->next != NULL) // 判斷目前是否為最後一個節點
                                {
                                    current = current->next;
                                }
                                current -> next = new_node; // 是最後一個節點則指向新節點
                            }
                            else
                            {
                                first = new_node;
                            }
                            new_node->data = data;
                            new_node->next = NULL;

                            return first;
                        }
                      </code></pre> 
                    </section>
                </section>
            </section>

            <section>
                <h3>解答P7</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    &emsp;&emsp;定義函式 delete_the_front 刪除串列最前面的節點<br>
                    &emsp;&emsp;宣告指標 p 用於指向最前面的節點<br>
                    &emsp;&emsp;當 first 不是 NULL，令 p 指向 first，並令 first 指向下一個節點<br>
                    &emsp;&emsp;釋放 p 指向節點的空間，回傳 first
                    <section data-auto-animate>
                      <pre><code data-trim data-noescape>        
                        //刪除最前面節點，若 List 無節點，則不必刪除。
                        node_t *delete_the_front(node_t *first){
                            node_t *p=NULL;
                            if(first!=NULL){
                                p = first;
                                first = first -> next;
                            }
                            free(p);

                            return first;
                        }
                      </code></pre> 
                    </section>
                </section>
            </section>

            <section>
                <h3>解答P8</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    &emsp;&emsp;定義函式 delete_the_back 用於刪除串列最後面的節點<br>
                    &emsp;&emsp;宣告指標 current, p 分別指向新節點和最後面的節點<br>
                    &emsp;&emsp;判斷目前是否為最後一個節點<br>
                    &emsp;&emsp;若不是則檢查直到下一個節點為串列最後一個節點<br>
                    &emsp;&emsp;若目前為最後一個節點，設定 first 為 NULL<br>
                    &emsp;&emsp;釋放 p 指向的空間，回傳 first
                    <section data-auto-animate>
                      <pre><code data-trim data-noescape>        
                        //刪除最後面節點，若 List 已無節點，則不必刪除。
                        node_t *delete_the_back(node_t *first){
                            node_t *current, *p=NULL;
                            current = first;

                            if(first!=NULL){ // 判斷串列是否存在
                                if(current->next!=NULL) // 判斷目前是否為最後一個節點
                                {
                                    while (current->next->next != NULL) // 判斷下一個節點是否為最後一個節點
                                    {
                                        current = current->next;
                                    }
                                    p = current->next; // 將指標 p 指向下一個節點
                                    current -> next = NULL; // 將當前節點設為串列最後一個節點
                                }
                                else 
                                {
                                    first = NULL;
                                }   
                            }
                            free(p);

                            return first;
                        }
                      </code></pre> 
                    </section>
                </section>
            </section>

            <section>
                <h3>解答P9</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    &emsp;&emsp;定義函式 delete_x_node 用於刪除串列內資料為 x 的節點<br>
                    &emsp;&emsp;宣告指標 current, follow, p 分別指向當前節點、先前節點、被刪除節點<br>
                    &emsp;&emsp;分別判斷第一個節點與其他節點的資料是否為 x<br>
                    &emsp;&emsp;是則刪除並釋放被刪除節點的空間<br>
                    &emsp;&emsp;回傳 first
                    <section data-auto-animate>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers="|1-21|22-29|"><script type="text/template"> 
                        //刪除 List 內資料為 x 的節點；若 x 不存在則不刪除任何節點。
                        node_t *delete_x_node(node_t *first, int x){
                            node_t *current, *follow, *p=NULL; // 指向當前節點、先前節點、被刪除節點的三個指標
                            current = first;
                            bool find = true;

                            if(current->data == x ) // 判斷第一個節點的資料是否為 x
                            {
                                first = delete_the_front(first); // 是則用刪除第一個節點的函式 delete_the_front 進行刪除
                                return first;
                            }
                            while (current->data != x ) // 這種作法一次只能刪一個
                            {
                                follow = current; // 指向當前節點
                                current = current->next; // 指向下一個節點檢查
                                if(current == NULL)
                                {
                                    find = false;
                                    break;
                                }
                            }
                            if(find == true)
                            {
                                p = current;
                                follow->next = current->next; // 前一個節點指向下一個節點
                                free(p);
                            }

                            return first;
                        }
                      </script></code></pre> 
                    </section>
                </section>
            </section>

            <section>
                <h3>解答P10</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    &emsp;&emsp;定義函式 add_y_node 用於完成指令5<br>
                    &emsp;&emsp;宣告指標 current, previous 分別指向當前節點、新節點<br>
                    &emsp;&emsp;分別判斷第一個節點與其他節點的資料是否為 x <br>
                    &emsp;&emsp;是則在其後加入新節點並存入資料 y<br>
                    &emsp;&emsp;回傳 first
                    <section data-auto-animate>
                      <pre><code data-trim data-noescape>        
                        //搜尋 List 內資料為 x 的節點，並在其後加入數值 y 的新節點。若 x 不在 List 中，則不必加入 y 。
                        node_t *add_y_node(node_t *first,int x, int y){
                            node_t *current, *new_node;
                            current = first;
                            bool find = true;
                            while (current->data != x ) // 這種作法一次只能加一個
                            {
                                current = current->next;
                                if(current == NULL)
                                {
                                    find = false;
                                    break;
                                }
                            }
                            if(find == true)
                            {
                                new_node = malloc(sizeof(struct node_s)); // 建立新節點
                                new_node->data = y;
                                new_node->next = current->next; // 新節點指向當前節點的下一個節點
                                current->next = new_node; // 當前節點指向新節點
                            }
                            return first;
                        }
                      </code></pre> 
                    </section>
                </section>
            </section>

            <section>
                <h3>解答P11</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    &emsp;&emsp;定義函式 Reverse 用於反轉陣列<br>
                    &emsp;&emsp;宣告指標 previous, current, preceding 分別指向<br>
                    &emsp;&emsp;新串列的下一個節點、當前節點、舊串列的下一個節點<br>
                    &emsp;&emsp;當舊串列的下一個節點不為 NULL ，令 current 的 next 指向 previous<br>
                    &emsp;&emsp;令 current 指向舊串列剩下的第一個節點<br>
                    &emsp;&emsp;令 preceding 指向舊串列的下一個節點<br>
                    &emsp;&emsp;反轉結束，令 first 為 current，回傳 first
                    <section data-auto-animate>
                      <pre><code data-trim data-noescape>        
                        // 反轉 Link List。
                        node_t *Reverse(node_t *first)
                        {
                            node_t *previous = NULL, *current = first, *preceding = first->next; // 指向新串列的下一個節點、當前節點、舊串列的下一個節點的三個指標
                          
                            // new:{NULL}, old:{1, 2, 3, 4, 5, NULL} -> {1, NULL}, {2, 3, 4, 5, NULL} 
                            // -> {2, 1, NULL}, {3, 4, 5, NULL} > ... -> {5, 4, 3, 2, 1, NULL}, {NULL}
                            while (preceding != NULL) {
                                current->next = previous;      // 把current->next轉向（第一次操作會讓原本的 first -> next 指向 NULL）
                                previous = current;            // previous指向新串列的第一個節點
                                current = preceding;           // current指向舊串列剩下的第一個節點（當前要處理的節點）
                                preceding = preceding->next;   // preceding指向舊串列的下一個節點
                            }                                  // preceding更新成NULL即跳出while loop

                            current->next = previous;          // 此時current位於最後一個node, 將current->next轉向
                            first = current;

                            return first;
                        }
                      </code></pre> 
                    </section>
                </section>
            </section>

            <section>
                <h3>解答P12</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    &emsp;&emsp;定義函式 Change_position 用於交換數值為 x 和 y 節點的位置<br>
                    &emsp;&emsp;宣告一些指標和一些布林值<br>
                    &emsp;&emsp;判斷 x 節點是否存在，以及 x 節點是否為第一個節點<br>
                    &emsp;&emsp;判斷 y 節點是否存在，以及判斷 y 節點是否為最後一個節點
                    <section data-auto-animate>
                    <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers="|1-6|7-26|28-43|"><script type="text/template">      
                        // 交換數值為 x 和 y 節點的位置，若 x 或 y 不在 List中，則不必交換。
                        node_t *Change_position(node_t *first, int x, int y)
                        {   
                            node_t *current, *x_current, *x_previous = NULL, *y_current, *y_previous = NULL,*temp,*temp1;
                            current = first; // 用於尋找 x 節點和 y 節點的位置
                            bool find_x = true, find_y = true, x_front = false, y_back = false;

                            if(current->data == x ) // 判斷 x 節點是否為第一個節點
                            {
                                x_current = current;
                                x_front = true;
                            }
                            else
                            {
                                while (current->data != x )
                                {
                                    x_previous = current;
                                    current = current->next;
                                    x_current = current;
                                    if(current == NULL)
                                    {
                                        find_x = false;
                                        break;
                                    }
                                }
                            }

                            current = first; // 回復成初始值
                            while (current->data != y )
                            {
                                y_previous = current;
                                current = current->next;
                                y_current = current;
                                if(current == NULL)
                                {
                                    find_y = false;
                                    break;
                                }
                            }
                            if(find_y == true && current->next == NULL) // 判斷 y 節點是否為最後一個節點
                            {
                                y_back = true;
                            }
                      </script></code></pre> 
                    </section>
                </section>
            </section>

            <section>
                <h3>解答P13</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    &emsp;&emsp;判斷 x 節點與 y 節點的關係並交換<br>
                    &emsp;&emsp;回傳 first
                    <section data-auto-animate>
                      <pre><code data-trim data-noescape>
                            if(find_x == true && find_y == true)
                            {
                                if(x_front == true && y_back == false) // 當 x 節點為第一個節點且 y 節點不為最後一個節點
                                {
                                    x_current->next = y_current->next; // 將 x 節點指向 y 節點的下一個節點
                                    y_current->next = x_current; // 將 y 節點指向原本 x 節點的下一個節點
                                    first = y_current; // 設定 first 節點為 y 節點
                                }
                                else if(x_front == false && y_back == true) // 當 x 節點不為第一個節點且 y 節點為最後一個節點
                                {
                                    x_previous->next = y_current; // 將 x 節點前面的節點指向 y 節點
                                    y_current->next = x_current; // 將 y 節點的下一個節點指向原本的 x 節點的下一個節點
                                    x_current->next = NULL; // 將 x 節點指向 NULL
                                }
                                else if(x_front == true && y_back == true) // 當 x 節點為第一個節點且 y 節點為最後一個節點
                                {
                                    y_current->next = x_current->next;// 將 y 節點的下一個節點指向原本的 x 節點的下一個節點
                                    y_previous->next = x_current; // 將 y 節點的前一個節點指向 x 節點
                                    first = y_current; // 將 first 指向 y 節點
                                    x_current->next = NULL; // 將 x 節點指向 NULL
                                }
                                else // 當 x 節點不為第一個節點且 y 節點不為最後一個節點
                                {
                                    temp = x_current->next; // 將 temp 指向原本的 x 節點的下一個節點
                                    temp1 = y_current->next; // 將 temp1 指向原本的 y 節點的下一個節點
                                    x_previous->next = y_current; // 將原本的 x 節點前面的節點指向 y 節點
                                    y_previous->next = x_current; // 將原本的 y 節點前面的節點指向 x 節點
                                    x_current->next = temp1; // 將 x 節點指向原本的 y 節點的下一個節點
                                    y_current->next = temp; // 將 y 節點指向原本的 x 節點的下一個節點
                                }
                            }
                            return first;   
                        }
                      </code></pre> 
                    </section>
                </section>
            </section>

            <section>
                <h3>解答P14</h3>
                <section data-no="8" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    &emsp;&emsp;定義函式 printList 用於列印串列<br>
                    &emsp;&emsp;宣告指標 node 指向當前欲列印節點<br>
                    &emsp;&emsp;判斷 first 是否為空，若是列印 None<br>
                    &emsp;&emsp;若不是列印節點直到節點為空<br>
                    &emsp;&emsp;程式結束
                    <section data-auto-animate>
                      <pre><code data-trim data-noescape>        
                        //串列列印函數
                        void printList(node_t *first){
                            node_t *node = first; //將node指向第一個節點
                            if(first == NULL){
                                printf("None\n");
                            }else{
                                while(node != NULL){
                                    printf("%d ",node->data);
                                    node = node->next;
                                }
                                printf("\n");
                            }
                        }
                      </code></pre> 
                    </section>
                </section>
            </section>

        </div>
    </div>
    <div id="pageIndex"></div>
    <!-- reveal.js-->
    <script src="vendor/reveal/reveal.js"></script>
    <!--plugin-->
    <script src="vendor/reveal/plugin/math/math.js"></script>
    <script src="vendor/reveal/plugin/search/search.js"></script>
    <script src="vendor/reveal/plugin/zoom/zoom.js"></script>

    <script src="vendor/reveal/plugin/notes/notes.js"></script>
    <script src="vendor/reveal/plugin/markdown/markdown.js"></script>
    <script src="vendor/reveal/plugin/highlight/highlight.js"></script>
    <script src="main-ppt.js"></script>
</body>

</html>
