<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=1900">
    <title>o21-7</title>
    <style>
        html,
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
    <link rel="stylesheet" href="vendor/reveal/reset.css">
    <link rel="stylesheet" href="vendor/reveal/reveal.css">
    <link rel="stylesheet" href="vendor/reveal/theme/sky.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="vendor/reveal/plugin/highlight/zenburn.css">
    <!--edit-->
    <!-- Pollyfill script -->
    <script src="https://unpkg.com/core-js-bundle@3.6.1/minified.js"></script>
    <!-- Live2DCubismCore script -->
    <script src="./dist/live2dcubismcore.js"></script>
    <!-- Build script -->
    <script src="./dist/bundle.js"></script>
    <style>
        ul,
        ol {
            list-style: none;
            margin-left: 0;
        }

        .reveal {
            position: absolute;
            left: 0;
            top: 0;
            font-size: 26px;
        }

        #pageIndex {
            position: absolute;
            right: 24px;
            bottom: 24px;
            background: #000;
            color: #fff;
            font-size: 20px;
        }

        .controls {
            bottom: 24px !important;
        }
    </style>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <!--
            data-no: 老師網頁的cubism人物編號(從0開始，網頁上的編號-1)
            data-positionx: cubism人物水平位移範圍(建議-1 ~ 0.9)
            data-positiony: cubism人物垂直位移範圍(建議-0.9~0.4)
            data-scale: cubism人物縮放(建議1~2之間的小數值，最大極限是3)
            data-motionno: cubism人物指定動作編號(從0開始，請參閱model3.json檔案的ALL MOTION GROUP)
            -->
            
            <section>
                <h3>大數除法 (進階題2)</h3>
                <section data-no="6" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    給定被除數 a 及非零除數 k，兩數相除滿足此等式：a = kq + r，<br><br>
                    其中 q 為商數且必為整數，而 r 為餘數，且必為自然數，滿足 0 &lt;= r &lt; |k|<br><br><br><br>
                    <img src="img/ch8/illustrate6.png" style="display:block; margin:auto;">
                </section>
            </section>

            <section>
                <h3>大數除法 (進階題2)</h3>
                <section data-no="6" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <img src="img/ch8/in_out6-1.png" style="display:block; margin:auto;">
                </section>
            </section>

            <section>
                <h3>大數除法 (進階題2)</h3>
                <section data-no="6" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    <img src="img/ch8/in_out6-2.png" style="display:block; margin:auto;">
                </section>
            </section>

            <section>
                <h3>Tips</h3>
                <section data-no="17" data-auto-animate  data-positionx="0.75" data-positiony="0.05" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    <pre><code data-trim data-noescape>           
                        #include &lt;stdio.h&gt;
                        #include &lt;string.h&gt;
                        #include &lt;stdbool.h&gt;

                        int main()
                        {
                            char Dividend[40], Divisor[40],Divisor_copy[40],Quotient[40]; // 被除數(餘數), 除數, 除數副本, 商數
                            int a = 0, k = 0, a_k, a_k_copy; // 被除數的個位數index, 除數的個位數index, 被除數與除數相差值(a-k), 被除數與除數相差值副本
                            bool signed_1 = false, signed_2 = false, signed_Q = false; // false 表示正數, true 表示負數

                            // 輸入被除數、除數

                            // 找出被除數和除數個位數的index
                            a = strlen(Dividend) - 1;
                            k = strlen(Divisor) - 1;

                            // 如果被除數或除數為負數，則紀錄其為負數，只取數字(i.e. index都往前一格)，ex: -125 儲存成 125(變成 正數除以正數)

                            // 負數除以正數 或是 正數除以負數，商為負數

                            // 除數放大10的(a-k)次方倍，這樣程式執行時間能大幅減少
                            for(int i = k+1; i &lt;= a; i++)
                            {
                                Divisor[i] = '0';
                            }

                            // 開始進行相減

                                // 判斷被除數與除數間的大小

                                    // 若被除數 = 除數。則被除數 = 除數 * 10的(a-k)次方倍，可直接輸出商數、餘數 = 0
                                    // 若被除數 &gt; 除數。直接相減，不夠減，向前借位
                                    // 若被除數 &lt; 除數。判斷除數是否已變回原先的除數，若成立，表示已經無法再做減法，結束除法;若不成立，則除數 / 10後，繼續做減法
                            
                            // 若被除數為負數，且餘數不等於0，則 |商| + 1，且餘數 = 除數 - 餘數

                            // 輸出商數、餘數

                            return 0;
                        }
                    </code></pre>
                </section>
                
                <section data-no="17" data-positionx="0.75" data-positiony="0.05" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    例 :<br>
                    被除數 = 106 (a = 2)，除數 = 3 (k = 0)，要得到餘數，被除數就必須減掉除數35次<br><br>
                    執行過程:<br>
                    1. 除數放大10的(a-k)次方倍，也就是除數 * 10的2次方 = 300<br>
                    2. 被除數(106) &lt; 除數(300)，除數 = 除數 / 10 = 30<br>
                    3. 被除數(106) &gt; 除數(30)，被除數 = 被除數 - 除數 -> 106 - 30 = 76<br>
                    4. 被除數(76) &gt; 除數(30)，被除數 = 被除數 - 除數 -> 76 - 30 = 46<br>
                    5. 被除數(46) &gt; 除數(30)，被除數 = 被除數 - 除數 -> 46 - 30 = 16<br>
                    6. 被除數(16) &lt; 除數(30)，除數 = 除數 / 10 = 3<br>
                    7. 被除數(16) &gt; 除數(3)，被除數 = 被除數 - 除數 -> 16 - 3 = 13<br>
                    8. 被除數(13) &gt; 除數(3)，被除數 = 被除數 - 除數 -> 13 - 3 = 10<br>
                    9. 被除數(10) &gt; 除數(3)，被除數 = 被除數 - 除數 -> 10 - 3 = 7<br>
                    10. 被除數(7) &gt; 除數(3)，被除數 = 被除數 - 除數 -> 7 - 3 = 4<br>
                    11. 被除數(4) &gt; 除數(3)，被除數 = 被除數 - 除數 -> 4- 3 = 1<br>
                    12. 被除數(1) &lt; 除數(3)。且除數已變回原先的除數，表示已經無法再做減法，<br>
                    &emsp;&ensp;結束迴圈。             
                </section>



                <section data-no="17" data-positionx="0.75" data-positiony="0.05" data-scale="1" data-motionno="0"
                    style="text-align: left"><br><br>
                    結論:<br><br>
                    除數 = 300 時沒有減過被除數。此時的除數是原先的除數乘以100倍<br>
                    除數 = 30 時減過3次被除數。此時的除數是原先的除數乘以10倍<br>
                    除數 = 3 時減過5次被除數。此時的除數是原先的除數乘以1倍<br>
                    商數 = 3 * 10 + 5 * 1 = 35<br>
                    餘數 = 1<br><br>
                    ----------------------------------------------------------------------------------------------
                    <br><br>
                    &emsp;106  &ensp;/&ensp;   &ensp;3  &ensp;=&emsp;  35 + 1<br>
                    &emsp;106  &ensp;/&ensp; (-3) &ensp;=&ensp; -35 + 1<br>
                    (-106) &ensp;/&ensp;  &ensp; 3  &ensp;=&ensp; -36 + 2<br>
                    (-106) &ensp;/&ensp; (-3) &ensp;=&ensp;  36 + 2<br><br>
                    若被除數為負數，且餘數不等於0，則 |商| + 1，且餘數 = |除數| - 餘數
                </section>
            </section>

            <section>
                <h3>strncmp</h3>
                <section data-no="17" data-positionx="0.8" data-positiony="0.03" data-scale="1" data-motionno="0"
                    style="text-align: left"><br>
                    strncmp(str1, str2, n);<br><br>
                    char str1[5] = "123";<br>
                    char str2[5] = "124";<br>
                    則 strncmp(str1, str2, 2) == 0<br>
                    strncmp(str1, str2, 3) < 0<br><br>

                    如果返回值小於 0，則表示 str1 的前 n 個字元小於 str2<br>
                    如果返回值等於 0，則表示 str1 的前 n 個字元等於 str2<br>
                    如果返回值大於 0，則表示 str1 的前 n 個字元大於 str2<br><br>
                </section>
            </section>

            <section>
                <h3 >解答P1</h3>
                <section
                data-no="8"
                data-positionx="0.8" 
                data-positiony="0.03" 
                data-scale="1" 
                data-motionno="0"
                style="text-align: left"><br><br>
                &emsp;首先引入函式庫與宣告變數<br>
                &emsp;宣告4個字元陣列分別存放被除數(餘數)、除數、除數副本和商數<br>
                &emsp;宣告整數變數 a, k 分別存放被除數、除數的個位數索引值<br>
                &emsp;宣告整數變數 a_k, a_k_copy 分別存放兩數相差位數、相差位數副本<br>
                &emsp;宣告整數變數 index, count 分別存放相減當下的索引值、共相減幾次<br>
                &emsp;宣告整數變數 mode 表示如何處理兩數相減<br>
                &emsp;宣告布林值 start, is_zero 分別用於正確輸出商數與餘數、判斷餘數是否為零<br>
                &emsp;宣告布林值 signed_1, signed_2, signed_Q 分別判斷被除數、除數與商是否為負
                  <section data-auto-animate>
                      <pre><code data-trim data-noescape>
                        #include &lt;stdio.h&gt;
                        #include &lt;string.h&gt;
                        #include &lt;stdbool.h&gt;

                        int main()
                        {
                            //   106  /   3  =  35 + 1
                            //   106  / (-3) = -35 + 1 
                            // (-106) /   3  = -36 + 2
                            // (-106) / (-3) =  36 + 2
                            char Dividend[40], Divisor[40],Divisor_copy[40],Quotient[40]; // 被除數(餘數), 除數, 除數副本, 商數
                            int a = 0, k = 0, a_k, a_k_copy; // 被除數的個位數index, 除數的個位數index, 被除數與除數相差值(a-k), 被除數與除數相差值副本
                            int  index = 0, count = 0; // 被除數與除數相減的index, 計算共減了幾次
                            int mode = 0; // 0 表示相除為10的倍數, 1 表示可繼續作除法, 2 表示無法繼續作除法
                            bool start = false; // 商數前面的0不顯示,直到遇到非0數字開始輸出
                            bool signed_1 = false, signed_2 = false, signed_Q = false; // false 表示正數, true 表示負數
                            bool is_zero = true; // true 表示餘數為0
                      </code></pre> 
                  </section>
                </section>
            </section>

            <section>
                <h3 >解答P2</h3>
                <section
                data-no="8"
                data-positionx="0.8" 
                data-positiony="0.03" 
                data-scale="1" 
                data-motionno="0"
                style="text-align: left"><br><br>
                &emsp;&emsp;讓使用者輸入被除數與除數<br>
                &emsp;&emsp;使用函式 strlen 將被除數與除數的長度存進整數變數 a 和 k<br>
                &emsp;&emsp;再各自減一得到各自個位數的索引值
                  <section data-auto-animate>
                      <pre><code data-trim data-noescape>
                        scanf("%s", Dividend);
                        scanf("%s", Divisor);

                        // 找出被除數和除數個位數的index
                        a = strlen(Dividend) - 1;
                        k = strlen(Divisor) - 1;
                      </code></pre> 
                  </section>
                </section>
            </section>

            <section>
                <h3 >解答P3</h3>
                <section
                data-no="8"
                data-positionx="0.8" 
                data-positiony="0.03" 
                data-scale="1" 
                data-motionno="0"
                style="text-align: left"><br><br>
                &emsp;&emsp;當被除數或除數的第一個字元為負號時，記錄其為負數<br>
                &emsp;&emsp;若被除數為負數，將布林值 signed_1 設定為 true ， 用來表示被除數為負數<br>
                &emsp;&emsp;若除數為負數，將布林值 signed_2 設定為 true ， 用來表示除數為負數<br>
                &emsp;&emsp;將位數全部向前移位去負號，以便運算，並將原本的最後一位設定為結束符號<br>
                &emsp;&emsp;根據被除數和除數的正負判斷商是否為負，是將布林值 signed_Q 設定為 true
                  <section data-auto-animate>
                      <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers="|1-13|15-25|27-29|"><script type="text/template">   
                        // 如果被除數或除數為負數，則記錄其為負數，只取數字(i.e. index都往前一格)，ex: -125 儲存成 125(變成 正數除以正數)

                        if(Dividend[0] == '-')
                        {
                            signed_1 = true;

                            for(int i = 0; i < a; i++)
                            {
                                Dividend[i] = Dividend[i+1];
                            }
                            Dividend[a] = '\0';
                            a--;
                        }

                        if(Divisor[0] == '-')
                        {
                            signed_2 = true;

                            for(int i = 0; i < k; i++)
                            {
                                Divisor[i] = Divisor[i+1];
                            }
                            Divisor[k] = '\0';
                            k--;
                        }

                        // 負數除以正數 或是 正數除以負數，商為負數
                        if((signed_1 == true && signed_2 == false)||(signed_1 == false && signed_2 == true))
                            signed_Q = true;
                      </script></code></pre> 
                  </section>
                </section>
            </section>

            <section>
                <h3 >解答P4</h3>
                <section
                data-no="8"
                data-positionx="0.8" 
                data-positiony="0.03" 
                data-scale="1" 
                data-motionno="0"
                style="text-align: left"><br><br>
                &emsp;&emsp;將被除數和除數相差的位數存進變數 a_k 與 a_k_copy<br>
                &emsp;&emsp;將目前的除數存進字元陣列 Divisor_copy<br>
                &emsp;&emsp;將除數放大10的(a-k)次方倍，令程式執行時間大幅減少
                  <section data-auto-animate>
                      <pre><code data-trim data-noescape>
                        a_k = a - k; // 被除數和除數相差的位數
                        a_k_copy = a_k;

                        // copy除數
                        for(int i = a; i >= a-k ; i--)
                        {
                            Divisor_copy[i] = Divisor[i-(a-k)];
                        }
                        for(int i = a-k-1; i >= 0 ; i--)
                        {
                            Divisor_copy[i] = '0';
                        }

                        // 除數放大10的(a-k)次方倍，這樣程式執行時間能大幅減少 (長除法補零)
                        // 除法過程中被除數和除數不斷相減，而一次減十倍比減十次快很多，以此類推
                        for(int i = k+1; i <= a; i++)
                        {
                            Divisor[i] = '0';
                        }
                      </code></pre> 
                  </section>
                </section>
            </section>

            <section>
                <h3 >解答P5</h3>
                <section
                data-no="8"
                data-positionx="0.8" 
                data-positiony="0.03" 
                data-scale="1" 
                data-motionno="0"
                style="text-align: left"><br><br>
                &emsp;&emsp;判斷被除數與除數間的大小<br>
                &emsp;&emsp;若被除數大於除數，設定 mode 為 1<br>
                &emsp;&emsp;若被除數小於除數，設定 mode 為 2<br>
                &emsp;&emsp;若每一位都一樣，mode 會保持 0 
                  <section data-auto-animate>
                      <pre><code data-trim data-noescape>
                        // 開始進行相減
                        while (1)
                        {
                            // 判斷被除數與除數間的大小，若每一位都一樣 mode 會保持零
                            for(int i = 0; i <= a; i++)
                            {
                                if(Dividend[i] > Divisor[i])
                                {
                                    mode = 1; 
                                    break;
                                }
                                else if (Dividend[i] < Divisor[i])
                                {
                                    mode = 2;
                                    break;
                                }
                                else{}
                            }
                      </code></pre> 
                  </section>
                </section>
            </section>

            <section>
                <h3 >解答P6</h3>
                <section
                data-no="8"
                data-positionx="0.8" 
                data-positiony="0.03" 
                data-scale="1" 
                data-motionno="0"
                style="text-align: left"><br><br>
                &emsp;&emsp;若 mode 為 0 ，表示 被除數 = 除數 * 10的(a_k)次方<br>
                &emsp;&emsp;令 count 加一，並乘上 10的(a_k)次方<br>
                &emsp;&emsp;若布林值 signed_Q 為 true，印出負號<br>
                &emsp;&emsp;印出商 count 與餘數 0，主函式結束
                  <section data-auto-animate>
                      <pre><code data-trim data-noescape>
                        if(mode == 0) // 表示 被除數 = 除數 * 10的(a_k)次方
                        {
                            count++; // 初始值 0，加一後變為 1
                            for(int i = 0; i < a_k;i++)
                            {
                                count = count * 10;
                            }

                            if(signed_Q == true)
                                printf("-");
                            printf("%d",count);

                            printf("\n0");

                            return 0;
                        }
                      </code></pre> 
                  </section>
                </section>
            </section>

            <section>
                <h3 >解答P7</h3>
                <section
                data-no="8"
                data-positionx="0.8" 
                data-positiony="0.03" 
                data-scale="1" 
                data-motionno="0"
                style="text-align: left"><br><br>
                &emsp;&emsp;若 mode 為 1 ，表示被除數大於除數<br>
                &emsp;&emsp;從第 a 個位置（個位數）開始往前做減法<br>
                &emsp;&emsp;被除數當下的位大於除數的位，則直接相減<br>
                &emsp;&emsp;若不夠減，從前一位開始借，若前一位無法借則向前借位直到得以相減<br>
                &emsp;&emsp;借的不是前一位時，將借的位後一位到當下位的前一位為止存為 '9'<br>
                &emsp;&emsp;'10' 減除數當下數字後得到差值，再加上被除數當下數字得到相減結果
                  <section data-auto-animate>
                      <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers="|1-9|10-29|31-35|"><script type="text/template">   
                        else if(mode == 1) // 被除數 > 除數
                        {
                            index = a; // 從個位數開始做減法
                            while (1)
                            {
                                if(Dividend[index] >= Divisor[index]) // 被除數當下的位大於除數的位，則直接相減
                                {
                                    Dividend[index] = Dividend[index] - Divisor[index] +'0';
                                }
                                else // 不夠減，向前借位
                                {
                                    int borrow = index-1;
                                    while(1)
                                    {
                                        if(Dividend[borrow] > 0)
                                        {
                                            Dividend[borrow] = Dividend[borrow] - 1 ; // 前一位減一
                                            for(int i = borrow + 1; i < index; i++) // 借的不是前一位時，補上 '9' 直到前一位為止
                                            {
                                                Dividend[i] = '9';
                                            }
                                            Dividend[index] = 10 +'0' - Divisor[index] + Dividend[index]; // '10' 減除數當下數字後加上被除數當下數字
                                            break;
                                        }
                                        else
                                            borrow--; // 不夠借則再往前借
                                    }
                                }
                                index--; // 往前一位繼續相減

                                if(index < 0)
                                    break;
                            }
                            count++; // 被除數每減完一次除數，則 count = count + 1
                        } 
                      </script></code></pre> 
                  </section>
                </section>
            </section>

            <section>
                <h3 >解答P8</h3>
                <section
                data-no="8"
                data-positionx="0.8" 
                data-positiony="0.03" 
                data-scale="1" 
                data-motionno="0"
                style="text-align: left"><br><br>
                &emsp;&emsp;若 mode 為 2 ，表示被除數小於除數<br>
                &emsp;&emsp;判斷除數是否已變回原先的除數<br>
                &emsp;&emsp;若成立，表示已經無法再做減法，結束除法<br>
                &emsp;&emsp;若不成立，則除數除以十後繼續做減法<br>
                &emsp;&emsp;將 count 的值加上字元 '0' 存進存放商數的字元陣列 Quotient
                  <section data-auto-animate>
                      <pre><code data-trim data-noescape>
                        else // 被除數 < 除數
                        {
                            // 判斷除數是否已變回原先的除數，若成立，表示已經無法再做減法，結束除法;若不成立，則除數 / 10後，繼續做減法
                            if(strncmp(Divisor_copy, Divisor, a+1) == 0) // 因為 Divisor 已經放大10的(a-k)次方倍，所以需要比到第 a+1 個元素才可以確定是否一致
                            {
                                Quotient[a_k] = count + '0'; // 將 count 的值加上字元 '0' 存進存放商數的字元陣列 Quotient
                                break; // 已經無法再做減法，結束除法
                            }
                            else
                            {
                                for(int i = a; i > 0; i--) // 除數 / 10
                                {
                                    Divisor[i] = Divisor[i-1]; // 將陣列數字往右移一位
                                }
                                Divisor[0] = '0'; // 將第一位歸零
                                Quotient[a_k] = count + '0'; // 將 count 作為字元存進存放商數的陣列 Quotient
                                count = 0; // 將 count 歸零
                                a_k--; // 被除數和除數相差的位數減 1
                            }
                        }
                    }
                      </code></pre> 
                  </section>
                </section>
            </section>

            <section>
                <h3 >解答P9</h3>
                <section
                data-no="8"
                data-positionx="0.8" 
                data-positiony="0.03" 
                data-scale="1" 
                data-motionno="0"
                style="text-align: left"><br><br>
                &emsp;&emsp;若被除數為負數，且餘數不等於零，則 |商| + 1，且餘數 = |除數| - 餘數<br>
                &emsp;&emsp;檢查餘數 (除完的被除數 Dividend) 是否為零<br>
                &emsp;&emsp;任一位非零則將布林值 is_zero 設為 false 並結束 for 迴圈<br>
                &emsp;&emsp;若餘數非零，令商加一，且令除數與當前餘數相減得到最終的餘數
                  <section data-auto-animate>
                      <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers="|1-11|12-22|23-43|44-48|"><script type="text/template">   
                        // 若被除數為負數，且餘數不等於0，則 |商| + 1，且餘數 = |除數| - 餘數
                        if((signed_1 == true && signed_2 == true) || (signed_1 == true && signed_2 == false))
                        {   
                            for(int i = 0; i <= a; i++) // 檢查餘數 (除完的被除數 Dividend) 是否在長度內皆為 '0' 
                            {
                                if(Dividend[i] != '0' )
                                {
                                    is_zero = false;
                                    break;
                                }
                            }
                            if(is_zero == false) // 餘數不等於0
                            {
                                Quotient[0] += 1; // 被除數為負數所以 |商| + 1 ，例：-10/3 = -4 ... 2 

                                index = a;
                                while (1)
                                {
                                    if(Divisor[index] >= Dividend[index]) // 若除數當下的數字大於等於餘數當下的數字，餘數 = |除數| - 餘數
                                    {
                                        Dividend[index] = Divisor[index] - Dividend[index] +'0';
                                    }
                                    else // 若除數當下的數字小於餘數當下的數字，借前一位達成 餘數 = |除數| - 餘數
                                    {
                                        int borrow = index-1;
                                        while(1)
                                        {
                                            if(Divisor[borrow] > 0) // 當前一位大於零時，借一當十；否則繼續往前借
                                            {
                                                Divisor[borrow] = Divisor[borrow] - 1 ;
                                                for(int i = borrow + 1; i < index; i++) // 如果是向前一位以前的位數借一當十會進入此迴圈
                                                {
                                                    Divisor[i] = '9';
                                                }
                                                Dividend[index] = 10 +'0' - Dividend[index] + Divisor[index]; // '10' 減除數當下數字後加上被除數當下數字
                                                break;
                                                }
                                            else
                                                borrow--; // 往前找大於零的位數
                                        }
                                    }
                                    index--; // 持續往前相減

                                    if(index < 0) // 索引值小於零不屬於陣列範圍，表示減法結束，離開迴圈
                                        break;
                                }
                            }
                        }
                      </script></code></pre> 
                  </section>
                </section>
            </section>

            <section>
                <h3 >解答P10</h3>
                <section
                data-no="8"
                data-positionx="0.8" 
                data-positiony="0.03" 
                data-scale="1" 
                data-motionno="0"
                style="text-align: left"><br><br>
                &emsp;&emsp;輸出商數，從末位開始反向輸出<br>
                &emsp;&emsp;輸出餘數，從第一位開始輸出<br>
                &emsp;&emsp;程式結束
                  <section data-auto-animate>
                      <pre data-id="code-animation"><code class="hljs javascript" data-trim data-line-numbers="|1-15|17-32|"><script type="text/template">   
                        // 輸出商數
                        if(signed_Q == true) // 商為負數加負號
                            printf("-");

                        for(int i = a_k_copy; i >= 0; i--) // 找到商的非零位置後輸出
                        {
                            if(Quotient[i] != '0' )
                                start = true;

                            if(start == true)
                                printf("%c",Quotient[i]);
                        }
                        printf("\n");

                        start = false;

                        // 輸出餘數
                        for(int i = 0; i <= a; i++) // 找到餘數的非零位置後輸出
                        {
                            if(Dividend[i] != '0' )
                                start = true;

                            if(start == true)
                                printf("%c",Dividend[i]);
                        }

                        // 餘數為0時，輸出0
                        if(start == false)
                            printf("0");

                        return 0;
                    }
                      </script></code></pre> 
                  </section>
                </section>
            </section>


        </div>
    </div>
    <div id="pageIndex"></div>
    <!-- reveal.js-->
    <script src="vendor/reveal/reveal.js"></script>
    <!--plugin-->
    <script src="vendor/reveal/plugin/math/math.js"></script>
    <script src="vendor/reveal/plugin/search/search.js"></script>
    <script src="vendor/reveal/plugin/zoom/zoom.js"></script>

    <script src="vendor/reveal/plugin/notes/notes.js"></script>
    <script src="vendor/reveal/plugin/markdown/markdown.js"></script>
    <script src="vendor/reveal/plugin/highlight/highlight.js"></script>
    <script src="main-ppt.js"></script>
</body>

</html>
